directory = '/Users/hongfusun/workspace';
cd(directory)
acceleratedPfile = fullfile(directory, 'P94208.7');
calibrationPfile = fullfile(directory, 'P89088.7');

% AssetRecon(pfile, calibration);

% Load accelerated Pfile
pfile = GERecon('Pfile.Load', acceleratedPfile);

% Run calibration on reference Pfile
GERecon('Calibration.Process', calibrationPfile);

% unaliasedImage_all = zeros(pfile.xRes, pfile.yRes, pfile.slices, pfile.channels);

for s = 1:pfile.slices
    for c = 1:pfile.channels

        % Load K-Space
        kspace = GERecon('Pfile.KSpace', s, 1, c);

        % Transform K-Space. Applies an apodization filter, performs a
        % 2D inverse Fourier transform, scales the data and returns the 
        % resulting image space data.
        % If both Homodyne and Asset are enabled for
        % the currently active pfile then ASSET must be run on both the 
        % high pass filtered and low pass filtered images generated by 
        % the Homodyne algorithm. For this use case, the third 
        % dimension of the returned aliased image has a size of 2. 
        % The first index of the third dimension contains the high pass 
        % filtered aliased image and the second index contains the low 
        % pass filtered aliased image.
        % See the Asset.Unalias command below for additional details.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% in theory method 1 and 3 are the same, however, phase is wrong
% method 2 is correct for phase, however ASSET does it wrong

% % method 1
%         kspace = padarray(kspace,[0, 64], 'both');
%         aliasedImage = ifft(ifft(kspace,256,1),256,2);
%         aliasedImage = fftshift(fftshift(aliasedImage,1),2);
%         aliasedImage = aliasedImage*256;

% % method 2
% % phase at this stage looks good. Correct way, however will mess up by ASSET (wrong way)
%         kspace = padarray(kspace,[0, 64], 'both');
%         kspace = fftshift(fftshift(kspace,1),2);
%         aliasedImage = fft(fft(kspace,256,1),256,2);
%         aliasedImage = fftshift(fftshift(aliasedImage,1),2);
%         aliasedImage = aliasedImage/256;
%         %%% seems like need flip to be the same as method 1 and 3, also circshift
%         aliasedImage = flipdim(flipdim(aliasedImage,1),2);
%         aliasedImage = circshift(aliasedImage,[1 1]);


% method 3
        aliasedImage = GERecon('Transform', kspace);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


        aliasedImages(:,:,c,:) = aliasedImage;

        aliasedImage_all(:,:,c,:,s) = aliasedImage;
    end

    % Get corners and orientation for this slice location via
    % the Pfile.Info interface.  This structure provides enough
    % slice information to support slice ASSET acceleration.
    info = GERecon('Pfile.Info', s);
        
    % Apply Asset Unaliasing.                
    % If both Homodyne and Asset are enabled then ASSET must be run on
    % both the high pass filtered and low pass filtered aliased images.
    % The high pass filtered and low pass filtered images can be passed
    % to the Asset.Unalias command in the fourth dimension of the
    % aliasedImages array. The first index of this additional fourth
    % dimension represents high pass filtered images and the second
    % dimension represents low pass filtered images.
    % For all use cases, the first two dimensions contain the aliased
    % image data and the third dimension represents the channel index
    % for a given aliased image.
    unaliasedImage = GERecon('Asset.Unalias', aliasedImages, info);

    unaliasedImage_all(:,:,s) = unaliasedImage;

    % Create Magnitude Image
    magnitudeImage = abs(unaliasedImage);
    
    % Apply Gradwarp
    gradwarpedImage = GERecon('Gradwarp', magnitudeImage, info.Corners);

    % Orient the image and corners
    finalImage = GERecon('Orient', gradwarpedImage, info.Orientation);

    % Display
    imagesc(finalImage);
    
    % Display
    title(['Slice: ' num2str(s)]);

    % Save DICOMs
    filename = ['DICOMs/image' num2str(s) '.dcm'];
    GERecon('Dicom.Write', filename, finalImage, s, ...
        info.Orientation, info.Corners);

    pause(0.1);
end

% note that method 2, after ASSET, phase is messed
nii = make_nii(abs(aliasedImage_all));
save_nii(nii,'aliasedImage_all.nii');
nii = make_nii(angle(aliasedImage_all));
save_nii(nii,'aliasedImage_all_pha.nii');

nii = make_nii(abs(unaliasedImage_all));
save_nii(nii,'unaliasedImage_all.nii');
nii = make_nii(angle(unaliasedImage_all));
save_nii(nii,'unaliasedImage_all_pha.nii');



% correct for phase (fftshift)
% note that the correction works for method 1 and 3, not method 2
% summary: use method 1 or 3, to be consistent with GE implemented of ASSET

% go back to the previous kspace
k = fftshift(fftshift(unaliasedImage_all,1),2);
k = ifft(ifft(k,256,1),256,2);

% proper transformation
k = fftshift(fftshift(k,1),2);
unaliasedImage_all_new = fft(fft(k,256,1),256,2);
unaliasedImage_all_new = fftshift(fftshift(unaliasedImage_all_new,1),2);

% correct for phase cycling
unaliasedImage_all_new(:,:,2:2:end) = unaliasedImage_all_new(:,:,2:2:end)*exp(1j*pi);

nii = make_nii(abs(unaliasedImage_all_new));
save_nii(nii,'unaliasedImage_all_new.nii');
nii = make_nii(angle(unaliasedImage_all_new));
save_nii(nii,'unaliasedImage_all_new_pha.nii');



